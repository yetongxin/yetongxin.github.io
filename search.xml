<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm 垃圾收集器]]></title>
    <url>%2F2019%2F08%2F02%2Fjvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对象存活判断引用计数算法给对象添加一个引用计数器，一个地方引用它就加1，引用失效就减1，计数器值为0对象就是不可以再使用的 缺点：难以解决对象之间相互循环引用的问题。 例如：obj1.item = obj2; obj2.item = obj1，即使已经无效，引用计数也不为0，无法回收。 可达性分析以一系列的“GC Roots”作为起始点，从这些节点开始往下面搜索，搜索路径叫做引用链，当一个对象不存在与GC Roots相连的引用链（图的不可达），证明对象不可用。 GC Root通常包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 引用分类 强引用：类似Object obj = new Object()，强引用存在时垃圾收集器永远不会回收 软引用：SoftReference类，将要发生内存溢出前进行第二次回收，如果这次回收后内存还是不够，抛内存溢出异常 弱引用：WeakReference类，只能生存到下一次GC前，内存足够也会回收 虚·引用：PhantomReference类，不影响实例生存时间，无法取得实例，唯一作用是被GC时收到一个系统通知 finalize()方法宣告对象死亡至少需要2次标记过程：与GC ROOT无相连引用链被标记，再判断是否有必要执行finalize()方法，如果没有覆盖finalize()方法或者finalize()已经被调用过就认为是没必要执行。否则需要执行finalize()方法，此对象放入F-Queue队列中，由JVM的低优先级Finalizer线程去执行。稍后，GC会对F-Queue的对象进行第二次标记，如果对象在finalize()方法中拯救了自己（重新被引用），则将会被移出要回收的集合。 finalize()只会被调用一次，只能自救一回。 一般不覆盖finalize()方法，该方法设计之初是为了迎合C++语法的析构函数，应该用try-finally取代之。 方法区（永久代）的GC主要回收两部分内容：废弃常量和无用的类 废弃常量：比如“abc”不被引用了，会被清理出常量池 无用的类：需同时满足以下条件 该类所有实例已被回收； 加载该类的ClassLoader已被回收； 该类的Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法（思想）标记清除算法（Mark-Sweep）算法：先标记出所有需要回收的对象，然后统一回收被标记需要回收的对象。缺点： 标记和清除效率不高。会产生大量不连续的内存碎片，导致分配大对象时不得不触发另一次垃圾收集动作。 主要用于老年代（tenured generation） 复制（Copying）算法内存划分成等大小的两块，只有一块在使用，GC时将存活对象复制到另一块区域中，清除另一半。 缺点：有一半内存浪费，复制操作效率低，不适合老年代。（老年代存活率较高需要较多复制操作，不想浪费50%空间还得分配担保，而没有额外空间给老年代分配担保） 实际使用中并不是一半一半的内存分配，因为大部分对象生命周期很短，所以划分成一块很大的Eden区和两块小的Survivor区，一般默认8:1:1的比例。每次使用一块Eden和一块Survivor区，GC时将Eden和Survivor中存活的对象复制到另一块Survivor区中。当Survivor区不够大时，使用老年代进行分配担保，存活对象放入老年代。 主要用于新生代（new generation） 标记-整理算法(Mark-Compact)标记过程和标记清除算法一样，标记之后存活的对象向一端移动，最后清理掉边界以外的内存，保证内存的规整。 安全点HotSpot 虚拟机采取的是可达性分析算法。即通过 GC Roots 枚举判定待回收的对象。 那么，首先要找到哪些是 GC Roots。 有两种查找 GC Roots 的方法： 一种是遍历方法区和栈区查找（保守式 GC）。一种是通过 OopMap 数据结构来记录 GC Roots 的位置（准确式 GC）。 OopMap这个数据结构维护哪些地方存放着对象引用，记录栈上本地变量与堆中对象的引用关系，方便枚举GC Root。 在执行 GC 操作时，所有的工作线程必须停顿，这就是所谓的”Stop-The-World”。因为可达性分析算法必须是在一个确保一致性的内存快照中进行。如果在分析的过程中对象引用关系还在不断变化，分析结果的准确性就不能保证。 Hotspot并没有为每条指令都生成oopmap,只是在某些特定位置生成，这个对应 OopMap 的位置叫做安全点（Safe Point）。 网上看到的关于安全点的理解： 从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。 CPU在执行运算过程时需要把数据从内存中载入到寄存器，运算完后再从寄存器中载入到内存中，Java中对象地址也是这么个过程，设想如果一个Java线程分配一个对象，此时对象的地址还在寄存器中，这时候这个线程失去了CPU 时间片，而此时STW GC发现没有任何GC ROOTS与该对象关联起来，此时这个对象呗认为是垃圾并被回收了，之后CPU重新获得时间片后发现此时对象已经不存在了这时候程序就GG了。 一般会在如下几个位置选择安全点： 循环的末尾 方法临返回前 调用方法之后 抛异常的位置 那怎么让所有线程都跑到安全点呢？方法有二： 抢先式中断：GC时先中断所有线程，对于还没跑到安全点的线程，让其恢复并等它跑到安全点上再停。——现在几乎没有这样实现的； 主动式中断：GC需要中断线程时，设置一个标志，各个线程执行时，跑到安全点的时候轮询这个标志，发现标志为真的时候自己中断挂起。 接下来又遇到如果程序不执行（如Sleep、Block）时无法响应JVM的中断请求的问题，就需要安全区域来解决： 线程执行到安全区域的时候，标识自己进入了安全区域；则发动GC的时候，可以忽略标识为安全区域的线程；而线程在离开安全区域的时候，需要检查是否已完成GC Root枚举（或者是整个GC过程），没完成的话要GC发出等待离开的信号。 垃圾收集器 中间有连线的标识可以搭配使用。 Serial 最基本的 单线程，串行。现常用于客户端 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。年轻代，能与CMS收集器共用（是-XX:+UseConcMarkSweepGC的默认收集器），也可以使用-XX:+UseParNewGC来强制指定 Parallel Scavenge收集器新生代收集器，多线程、复制算法类似ParNew收集器，Parallel收集器更关注系统的吞吐量。吞吐量=(执行用户代码时间)/(执行用户代码时间+垃圾回收占用时间)-XX:MaxGCPauserMillis 垃圾收集器停顿时间-XX:GCTimeRatio 垃圾收集时间占总数比率（0-100）默认为99，GC比例1/（1+99）=1%-XX:+UseAdaptiveSizePolicy 开关参数，开了之后，-Xmn,-XX:SurvivorRatio、-XX:PretenureSizeThredshold不再需要手工指定 Serial Old收集器Serial收集器的老年代版本，单线程，标记-整理算法。 Parallel Old收集器Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法，JDK1.6开始提供。 CMS收集器老年代收集，设计目标是获取最短回收停顿时间，基于标记-清除算法设计，包括以下步骤： 初始标记：标记GC Root可以直接关联到的对象，速度很快，需要Stop The World； 并发标记：可达性分析枚举，耗时较长；可与用户线程并发执行 重新标记：修正并发标记期间因用户程序继续运行而导致的引用变动，需要Stop The World； 并发清除：耗时较长。可与用户线程并发执行 缺点： 对CPU资源敏感，并发阶段总吞吐量降低，CPU数量少的时候对用户程序影响大； 无法处理浮动垃圾（Floating Garbage），即并发清理阶段新产生的垃圾，要等到下一次GC；因此需要预留内存空间给用户线程使用，不能等内存快满才进行收集； 收集后产生内存碎片。（基于标记清除算法） G1收集器 并行与并发。可以真正的不停止应用来收集垃圾。 分代收集 空间整合 可预测的停顿 G1收集器将整个Java堆划分成多个大小相等的独立区域（Region），跟踪各个Region里面垃圾堆积的价值（根据回收所获得的空间大小及回收耗费时间的经验值），维护优先列表，每次收集的时候，根据允许的收集时间，优先回收价值更大的Region。此外每个Region维护一个Remembered Set来避免全堆扫描，引用型数据进行写操作的时候，会产生中断写操作，检查引用的对象是否处于不同的Region，如果是，则记录到被引用对象所属的Remember Set中；那么在GC时，GC Root的枚举范围加入Remembered Set，保证不进行全堆扫描也不会有遗漏。 回收步骤包括： 初始标记：与CMS一样； 并发标记：与CMS一样，包含Remembered Set； 最终标记：并发标记期间对象变化记录到Remembered Set Logs中，合并到Remembered Set； 筛选回收：先根据回收价值和回收成本进行排序，再根据用户期望GC停顿时间制定回收计划。 内存分配与回收策略-XX:+PrintGCDetails GC时打印内存回收日志 对象优先在Eden分配多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC； 大对象直接进入老年代大对象会导致虚拟机触发垃圾收集来获取连续空间安置它们提供-XX:PretenureSizeThreshold参数，大于此值的对象直接在老年代分配，避免在Eden区和Survivor区之间大量内存复制； 长期存活的对象将进入老年代JVM给每个对象定义一个Age计数器，在Eden出生并经过一次Minor GC后仍然存活，并且能被Suvivor容纳后将被移到Suvivor空间中并设置age = 1,接下来每熬过一次minor GC将+1,大到一定程度将晋升到老年代。默认15岁，通过-XX:MaxTenuringThreshold设置 动态对象年龄判定若Survivor区中同年龄所有对象大小总和大于Survivor空间一半，则年龄大于等于该年龄的对象可以直接进入老年代； 空间分配担保：Minor GC之前，JVM检查老年代最大可用连续空间大于新生代所有对象总空间，成立的话Minor GC确认是安全的；否则检查老年代最大可用连续空间大于历次晋升到老年代对象的平均大小，大于的话进行Minor GC；小于的话进行Full GC。 其它关于java的堆 这个部分可以参考博客：https://blog.csdn.net/sted_zxz/article/details/72476673 Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象，如下图所示： GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。Minor GC指发生在新生代的GC，频繁且快Full GC指发生在老年代的GC，慢 另外还有个永久代：永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间。永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分。永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在full GC时进行垃圾收集。 一些控制参数：-Xms设置堆的最小空间大小。-Xmx设置堆的最大空间大小。-Xmn：新生代的大小-XX:NewSize设置新生代最小空间大小。-XX:MaxNewSize设置新生代最大空间大小。-XX:PermSize设置永久代最小空间大小。-XX:MaxPermSize设置永久代最大空间大小。-Xss设置每个线程的堆栈大小。-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树创建与遍历]]></title>
    <url>%2F2019%2F08%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[节点定义：1234567891011121314151617181920class BinNode &#123;public: char data; BinNode* parent; BinNode* lchild; BinNode* rchild; BinNode()&#123; lchild = NULL; rchild = NULL; parent = NULL; &#125; BinNode(char data2):data(data2) &#123; lchild = NULL; rchild = NULL; parent = NULL; &#125; BinNode(char data2, BinNode* parent2):data(data2) &#123; lchild = NULL; rchild = NULL; parent = parent2; &#125; void insertAsLeft(char data) &#123; lchild = new BinNode(data,this); &#125; void insertAsRight( char data) &#123; rchild = new BinNode(data,this); &#125;&#125;; 树的定义：123456789101112131415161718192021class BinTree &#123;private: BinNode* root; string strtree;public: BinTree() &#123; root = NULL; &#125; BinNode* getRoot() &#123; return root; &#125;//获取根节点 void creatBTreeBycengci(string arr);//层次遍历产生一颗树，参考层次遍历 void creatBTreeByString(string str) ;//通过一个字符串创建一棵树，调用creatBTree BinNode* creatBTree(int&amp; pos);//通过先序遍历产生一棵树，使用递归 void preorder(BinNode* T) ;//先序遍历以T为根节点的子树，递归 void inorder(BinNode* T) ;//中序遍历以T为根节点的子树，递归 void postorder(BinNode* T) ;//后序遍历以T为根节点的字数，递归 void preorderByStack(BinNode* T);//先序遍历以T为根节点的子树，非递归 void inorderByStack(BinNode* T);//中序遍历以T为根节点的子树，非递归 void cengciByQueue(BinNode* T);//层次遍历，利用队列&#125; 以下是各种方法的实现:首先是通过一个字符串先序遍历创建一颗树 12345678910111213141516void creatBTreeByString(string str) &#123; int pos = 0; strtree.assign(str); root = creatBTree(pos);&#125;BinNode* creatBTree(int&amp; pos) &#123; BinNode* T; char ch = strtree[pos++]; if (ch == &apos;0&apos;) T = NULL; else &#123; T = new BinNode(ch); T-&gt;lchild = creatBTree(pos); T-&gt;rchild = creatBTree(pos); &#125; return T;&#125; 先序遍历、中序遍历、后序遍历的递归版本，此处无传如visit函数，只是访问节点的数据并输出： 12345678910111213141516171819202122void preorder(BinNode* T) &#123; if (T == NULL) return; char ch = T-&gt;data; cout &lt;&lt; ch; preorder(T-&gt;lchild); preorder(T-&gt;rchild); &#125; void inorder(BinNode* T) &#123;//中序遍历以T为根节点的子树 if (T == NULL) return; inorder(T-&gt;lchild); char ch = T-&gt;data; cout &lt;&lt; ch; inorder(T-&gt;rchild); &#125; void postorder(BinNode* T) &#123; if (T == NULL) return; postorder(T-&gt;lchild); postorder(T-&gt;rchild); char ch = T-&gt;data; cout &lt;&lt; ch; &#125; 先序遍历的非递归版本（使用栈）： 12345678910111213void preorderByStack(BinNode* T) &#123; stack&lt;BinNode*&gt; st; while (1) &#123; while (T != NULL) &#123; cout &lt;&lt; T-&gt;data ;// visit(T),先访问左孩子 st.push(T-&gt;rchild);//右孩子入栈，NULL也入栈，有进行判断，不会访问NULL T = T-&gt;lchild;//T 继续指向下一个左孩子 &#125; if (st.empty()) break;//所有右孩子都访问完了，结束。栈底是最上面的右孩子（它最先入栈） T = st.top(); st.pop();//pop出栈顶的右孩子，对其进行遍历 &#125; &#125; 中序遍历的非递归版本（使用栈）： 1234567891011121314151617181920void inorderByStack(BinNode* T) &#123; stack&lt;BinNode*&gt; st; while (1) &#123; while (T != NULL) &#123; st.push(T); T = T-&gt;lchild;//当跑到最左下方时， //当前节点即是left root right 中的root节点， //此时left相当于已经访问过，故接下来应该将控制权转给right &#125; if (!st.empty()) &#123; T = st.top(); st.pop(); cout &lt;&lt; T-&gt;data;//visit();每个节点访问完后都会试图访问 以右孩子为根节点的树， //完了之后才会访问这个节点对应的父节点（即当前的栈顶） T = T-&gt;rchild; &#125; else &#123; break; &#125; &#125;&#125; 层次遍历（使用队列）: 1234567891011 void cengciByQueue(BinNode* T) &#123; queue&lt;BinNode*&gt; q; q.push(T);//首先会push进根节点 while (!q.empty()) &#123; T = q.front(); q.pop(); cout &lt;&lt; T-&gt;data;//visit() if (T-&gt;lchild) q.push(T-&gt;lchild); if (T-&gt;rchild) q.push(T-&gt;rchild); &#125; &#125;&#125;; 给出一个字符串，可参考层次遍历的方法创建一棵树（使用队列）： 1234567891011121314151617181920212223void creatBTreeBycengci(string arr) &#123;//层次遍历产生一颗树，参考层次遍历 int pos = 0; queue&lt;BinNode*&gt; q2; char data = arr[pos++]; root = new BinNode(data); q2.push(root); BinNode* T = root; while (pos!=arr.length() ) &#123; T = q2.front(); q2.pop(); data = arr[pos++]; if (data != &apos;0&apos;) T-&gt;lchild = new BinNode(data); else T-&gt;lchild = NULL; data = arr[pos++]; if (data != &apos;0&apos;) T-&gt;rchild = new BinNode(data); else T-&gt;rchild = NULL; if(T-&gt;lchild) q2.push(T-&gt;lchild);//存在才推进去 if(T-&gt;rchild) q2.push(T-&gt;rchild); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F08%2F01%2Ftest%2F</url>
    <content type="text"><![CDATA[我是一级标题]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的博文]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%88%91%E7%9A%84%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexoblog1]]></title>
    <url>%2F2019%2F08%2F01%2Fhexoblog1%2F</url>
    <content type="text"><![CDATA[javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript后面的内容在首页不显示，只显示到这里]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
